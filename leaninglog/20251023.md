# 금일 계획

# Login Process 진행

# REST API 호출

현재 상황에서 로그인을 성공한다고 하더라도 jwt를 세션 스토리지에 저장했을 뿐이고 , 아직 getCars()의 결과값을 가져오지는 못한다.

이 이유는 기본적으로 Login 컴포넌트에서 얻은 토큰을 가지로 frontend 상에서 Carlist를 불러오지 못하고 있는 상황이기 대문이다.

carapi.ts에 getCars() 호출을 할 때 얻어온 jwt를 사용해야 하기 때문이다.
근데 jwtToken 값이 생각해보면 .then()에 걸려있기 때문에 일종의 지역변수이다. 그렇다면 Login 컴포넌트를 벗어나서는 사용할 수 없다는 의미가 된다.
그러면 끌고 와서 getCars() 함수에 jwt값을 넣어서 같이 GET요청을 보낼 수 있을지 고민

굳이 setItem을 한 이유에 대해서

생각해봐야 한다. -> carapi.ts에서 사용하려고

```ts
import axios from "axios";
import { CarResponse, Car, CarEntity } from "../types";

// 세션 스토리지 상에서 `Bearer` 가 포함되어있었다. 근데 Postman에서 요청 날릴 때 `Bearer` 부분을 빼놓고 붙여넣기가 했었던 것을 떠올려서
// 프론트 엔드 상에서 `Bearer`를 제거하고, 그걸 기준으로 요청을 날렸다.
export const getCars = async (): Promise<CarResponse[]> => {
  const token = sessionStorage.getItem("jwt");
  const response = await axios.get(`${import.meta.env.VITE_API_URL}/api/cars`, {
    headers: { Authorization: token },
  });
  return response.data._embedded.cars;
};
export const deleteCar = async (link: string): Promise<CarResponse> => {
  const token = sessionStorage.getItem("jwt");
  const response = await axios.delete(link, {
    headers: { Authorization: token },
  });
  return response.data;
};
export const addCar = async (car: Car): Promise<CarResponse> => {
  const token = sessionStorage.getItem("jwt");
  const response = await axios.post(
    `${import.meta.env.VITE_API_URL}/api/cars`,
    car,
    {
      headers: {
        "Content-Type": "application/json",
        Authorization: token,
      },
    }
  );
  return response.data;
};
export const updateCar = async (carEntity: CarEntity): Promise<CarResponse> => {
  const token = sessionStorage.getItem("jwt");
  const response = await axios.put(carEntity.url, carEntity.car, {
    headers: {
      "Content-Type": "application/json",
      Authorization: token,
    },
  });
  return response.data;
};
```

이상은 refactoring 전 부분. 위에 말했던 것처럼 token을 세션 스토리지에서 불러오고, 여기서 Bearer 접두사를 제거하는 부분 (springboot 상에서 제거했음) 그리고 headers 내에 'Authorization' : token 부분이 중복되고 있다는 것을 확인할 수 있다.

이 부분에서 알아야 할 점은 Scope 개념이다. 각 함수의 내부에서 token을 선언하고 Bearer 접두사를 제거하고 있기 때문에 함수 마다 선언 및 초기화를 하는 것

## 중복 코드 리팩토링

```ts
const getAxiosConfig = (): AxiosRequestConfig => {
  // const token = sessionStorage.getItem("jwt")?.replace("Bearer ","")
  const token = sessionStorage.getItem("jwt");
  return {
    headers: {
      Authorization: token,
      "Content-Type": "application/json",
    },
  };
};
```

이상에서 고려할 점은 getAxiosConfig의 return 타입으로 사용 된 AxiosRequestConfig이다.

- AxiosRequestConfig : Axios 라이브러리에서 HTTP 요청을 만들 때 사용되는 구성 객체 타입 정의에 해당한다. 즉, Axios를 경유하여 요청을 보내기 위해 필요한 _모든 옵션_ 을 담는 일종의 interface에 해당한다.

- axios.post(), .get ...과 같은 방식으로 사용한다. 이는 좀 더 가독성을 높이기 위한 방식으로 _메서드 별 요청_ 에 해당한다. 이 경우 endpoint 다음에 두 번째 argument로 사용된다.

```ts
// GET 요청이라고 가정
axios.get('http://localhost:8080/api/cars',
{ headers : {}'Autholization' : token})
```

2. 일반적인 요청 방식

```ts
axios({
  method: "get",
  url: "http://localhost:8080/api/cars",
  headers: {
    Autholization: token,
  },
});
```

이상의 1 , 2 과정 중에 return 타입에 객체 형태로 옵션들을 담을 수 있는 것을 AxiosRequestConfig라고 한다. 1 번 방법을 사용했기 때문에 getAxiosConfig() 함수의 정의가 간단한 편에 속한다. 2 번 방법이면 method 키의 value를 지정하는게 복잡하다.

인터셉터(interceptor)에서의 활용 : request intercetor는 요청이 서버로 가기 전에 가로채서 구성을 수정한다. 즉 getAxiosConfig() 함수 요청을 하게 되면 처음에는 token이 없는 상태로 DB까지 가게 될 뻔했는데, interceptor가 중간에 가로채서 headers를 추가해준다는 의미가 된다.

## Authentication 실패 시 오류 메세지를 토스트 메세지로 응용

```tsx
<Snackbar
  open={open}
  autoHideDuration={2000}
  onClose={() => setOpen(false)}
  message="로그인실패"
/>
```

라고 설정을 했다고 가정했을 때, setOpen을 호출하는 부분이 필요하다. Login 컴포넌트 중에 어떤 동작을 했을 때 toast message가 출력되어야 하며, 그래서 setOpen(true)코드를 작성해야 할까

```tsx
const handleLogin = async () => {
    console.log(sessionStorage.getItem("jwt"))
    axios.post(`${import.meta.env.VITE_API_URL + "/login"}`, user, {
      headers: {
        "Content-Type": "application/json",
      }
    })
      .then(res => {
        const jwtToken = res.headers.authorization;
        if (jwtToken !== null) {
          sessionStorage.setItem("jwt", jwtToken);
          setAuth(true)
        }
      }
      ).catch(err => {console.log(err) 
        setOpen(true)})
  }
```