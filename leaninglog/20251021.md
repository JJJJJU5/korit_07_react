# 환경 변수 이용

서버 URL은 CRUD 기능을 만들 떄 소스 코드에서 여러 번 반복될 수 있으며, 백엔드가 배포가 되면 localhost:8080이 아니기 대문에 환경 변수로 미리 정의해두는 것이 좋다. 예를 들어서 수정이 이루어지고 나면 갱신된 GetCars()
가 다시 요청되어야 한다. 그러면 수정 부분에 있는 localhost:8080과 다시 getCars()를 요청할 때의 localhost:8080을 매번 URL로 전부 다 고치는 것은 비효율적이다(그리고 이건 하드코딩에 해당한다).

그래서 환경변수 URL을 저장해두게 되면, URL이 바뀔 때 환경 변수만 수정해주면 일괄 변환이 될 것이기 때문에 환경 변수 설정을 미리 하고 다음 과정으로 넘어간다.

vite project 상에서는 환경 변수 이름은 `VITE_`로 시작하여아 한다. 접두사가 VITE\_인 변수만 소스 코드에서 접근이 가능하다.

1. 앱의 루트 포덜에 `.env` 파일을 생성.

`VITE_API_URL = http://localhost:8080`

2.src 폴더 내에 api 폴더 생성 -> carapi.ts 파일 생성

- 이상은 모든 API 호출 함수를 자체 모듈로 분리하는 과정이다. 즉 현재 상황에서는 getCars()를 Carlist 컴포넌트에서 분리해오겠다는 의미가 된다.

- .env 파일이 src 내부에 있는 경우가 있으면 URL을 찾지 못해서 Not Found 오류가 발생하기 때문에 가장 상위에 위치시킬 것.

# 페이징 / 필터링 / 정렬 추가

- github 때는 Ag Grid 사용, 이번에는 MUI 기준으로 작성 할 예정
- 터미널에서 npm install @mui/x-data-grid@8.4.0

# 삭제 기능 추가

- 이제 중요한 점은 삭제를 하기 위해서는 특정 row를 선택해야 한다는 점과, 엔드포인트에 {id}가 추가되어야 한다는 점이다.

- 우리는 각 row에 대한 href를 가지고 있다는 점에 주목할 필요가 있다.

```json
{
  "_embedded": {
    "cars": [
      {
        "brand": "Kia",
        "model": "Seltos",
        "color": "Chacol",
        "registrationNumber": "370SU5690",
        "modelYear": 2020,
        "price": 30000000,
        "_links": {
          "self": {
            "href": "http://localhost:8080/api/cars/1"
          },
          "car": {
            "href": "http://localhost:8080/api/cars/1"
          },
          "owner": {
            "href": "http://localhost:8080/api/cars/1/owner"
          }
        }
      }
    ]
  }
}
```

HATEOAS를 적용했기 때문에 각각의 id 값이 자동으로 설정되어있다. 즉 DELETE method를 \_links.self.href로 보내주면 알아서 삭제가 된다고 생각할 수 있다.

그래서 현재 GET 요청을 통해서 `import.meta.env.VITE_API_URL/api/cars`를 하게 됐을 때 x-data-grid에 의해서 각 자동차 row들이 나오고 있다. x-data=grid의 GridColDef를 수정하여 버튼을 하나 추가하고, 거기에 삭제 기능을 적용할 것.

왜냐하면 key 속성에 이미 \_link.self.href 값이 있기 때문이다.

GridColDef에 딸린 columns 상수를 수정하여 하나의 column을 추가했다. 여기에는 Delete 버튼을 할당했다. 다른 컬럼들과 달리 세세한 커스텀이 필요하기 때문에 renderCell 컬럼 속성을 사용하여 셀의 컨텐츠가 렌더링 되는 방식을 정의했다.(여기서는 button 태그를 집어넣었다).
그리고 현재 상황에서는 alert을 통해 \_links.self.href를 불러오는지를 확인했는데, 여기서 중요한 개념이 onClick={alert(\_links.self.href)}를 쓰게 되면 애초에 함수의 결과값이 출력될거기 때문에 버튼을 누르는 것과는 상관이 없다는 결과가 나온다.
onClick={()=> alert(\_links.self.href)}과의 차이점을 명확하게 알 필요가 있다.

함수의 이름을 이벤트 핸들러에 전달 / 함수의 결과를 이벤트 핸들러에 전달하는 것의 차이점을 복습할 필요가 있다. -> 그리고 매개변수가 존재하는 함수의 이름만 전달하는 방법이 무엇일까를 고려해야 한다.

button 태그 내에 sort / filter를 비활성화 시켰고, 컬럼의 메뉴를 비활성화 시키는 disableColumnMenu를 true로 설정했다.
그리고 onClick 이벤트도 설정했다.

다음 과정을 좀 고민해야 한다. 각 row들 마다 href가 존재하기 때문에 delete 요청을 날릴 수 있을 것.

현재까지의 코드를 확인해본 결과, 일단 cardatabase_2를 기준으로 지금 back-front 연결을 하고 있는 것은 맞는데, 얘가 Spring Data REST를 기반으로 하고 있다 보니 로직 설명이 되고 있다는 것을 알 수 있다.

즉, 코드 자체를 보고 로직을 떠올리기 위해서는 cardatabase_5의 CarController와 CarService를 확인할 필요가 있다.

Axios의 delete 메서드를 이용하여 DELETE 요청을 보내는데, DELETE 요청의 경우에는 id값이 필요하다는 것을 CarService에서 확인 할 수 있다.
그런데 id 값은 어디에 있다? href에 있다.

그리고 우리는 함수들을 frontend에서 다 분리를 했다, 그렇다면 deleteCar 함수를 작성해야 하는 파일은 어디가 되는지

```ts
import axios from "axios";
import { CarResponse } from "../types";
import { useQueryClient } from "@tanstack/react-query";
import { GridCellParams } from "@mui/x-data-grid";

export const getCars = async (): Promise<CarResponse[]> => {
  const response = await axios.get(`${import.meta.env.VITE_API_URL}/api/cars`);
  return response.data._embedded.cars;
};
export const deleteCar = async (link: string): Promise<CarResponse> => {
  const response = await axios.delete(link);
  return response.data;
};
```

getCars()의 return 타입과 deleteCar()의 return 타입의 차이를 생각할 필요가 있다. getCars()의 경우 자동차들의 정보를 담고있는 배열만 가지고 와서 그것을 Carlist 컴포넌트의 return에 표기하면 되는 반면에, 삭제 후에는 GET 요청 이후에 완전히 JSON이 return될 필요가 있다. 그 차이로 인해서.\_embedded 유무가 결정나는 것

현재 deleteCar() 메서드를 호출하기 위한 useMutation() hook을 적용했다. 그리고 삭제 버튼을 눌렀을 때 , 삭제가 DB에서는 됐지만 frontend 상에서는 새로고침을 해야지만 이루어진다는 점도 확인된다.

그렇다면 onSuccess는 삭제 이후에, 새로 프론트엔드에 갱신되어 cars 정보를 가지고 오는 것이 된다.

즉 , 이제 구현할 부분은 자동차가 삭제되면 프론트엔드를 자동으로 새로 고침할 수 있도록 하는 것. react query에서 가져온 데이터는 쿼리 클라이언트가 처리하는 캐시에 저장된다. 쿼리 클라이언트에는 데이터를 _다시 가져오는 데 이용할 수 있는 쿼리 무효화_ 기능이 있다.

물론 useEffect()에서 콜백함수를 통해 getCars()를 호출하는데, `[cars]`를 통해서 상태가 변화될 때마다 재렌더링을 일으키는 방법도 있다.

## 토스트 메세지 표시

이상에서 구현한 부분은 삭제를 했을 때 , cache를 확인하여 최신 정보를 가지고 오는 방식을 택했다. 하지만 1번 id를 가지는 정보를 삭제했을 때 야 바로 위에 없어졌는지 보으겠지만 20 개 중에 12번 쯤 되는 애를 삭제하면 렌더링 됐을 때 다시 1번부터 나올거니까 제대로 지워졌는지 체크하기 힘들 것

즉 UX 개선을 위하여 삭제되었다고 표시를 해주는 것
그런데 alert는 아니라 다른 방식으로.

### Snackbar

- 주목해야 할 것은 shoppinglist 앱에서 도입했었던 Modal과 유사한 성질을 지니고 있다는 점이다. 그래서 동일하게
  `const [open , setOpen] = useState(false);`
  그렇다면 특정 상황이 발생했을 때 setOpen(true)를 통해서 메세질르 출력하고, 다시 setOpne(false); 를 통해서 그 메세지가 사라져야 한다.

shoppinglist에서는 add item 버튼을 누르면 open이 true로 바뀌어서 modal 창이 렌더링 되었다.

그러면 삭제 후에 삭제되었다고 메세지를 띄우고 싶다면, Carlist에서 어느 부분에 setOpen(true);가 있어야 하는지.

```tsx
//Carlist
import { Snackbar } from "@mui/material";


 const [open, setOpen] = useState(false);
const { mutate } = useMutation(deleteCar, {
    onSuccess: () => {
      setOpen(true);
      queryClient.invalidateQueries({ queryKey: ["cars"] });
    }, onError: () => console.log('실패')
  })
  <Snackbar
        open={open}
        autoHideDuration={2000}
        onClose={() => setOpen(false)}
        message= "선택한 항목이 삭제되었습니다.❗"
  />
```
추가 된 부분

### confirm 상자 추가하기
button 태그 수정.


```tsx
renderCell: (params: GridCellParams) => (
  <button onClick={() => {
          if(window.confirm(`${params.row.brand}의 ${params.row.model} 자동차를 삭제하시겠습니까?`))
          mutate(params.row._links.self.href)}}>삭제</button>)
        }
```

추가된 부분
<br>

```tsx
//Carlist 최종본
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { deleteCar, getCars } from "../api/carapi";
import { DataGrid, GridColDef, GridCellParams } from "@mui/x-data-grid";
import { Snackbar } from "@mui/material";
import { useState } from "react";

function Carlist() {
  const [open, setOpen] = useState(false);
  const queryClient = useQueryClient();
  const { mutate } = useMutation(deleteCar, {
    onSuccess: () => {
      setOpen(true);
      queryClient.invalidateQueries({ queryKey: ["cars"] });
    },
    onError: () => console.log("실패"),
  });

  const columns: GridColDef[] = [
    { field: "brand", headerName: "브랜드", width: 150 },
    { field: "model", headerName: "모델", width: 150 },
    { field: "color", headerName: "색상", width: 150 },
    { field: "registrationNumber", headerName: "차량번호", width: 150 },
    { field: "modelYear", headerName: "연식", width: 150 },
    { field: "price", headerName: "가격", width: 150 },
    {
      field: "delete",
      headerName: "",
      width: 150,
      sortable: false,
      filterable: false,
      hideable: false,
      disableColumnMenu: true,

      renderCell: (params: GridCellParams) => (
        <button
          onClick={() => {
            if (
              window.confirm(
                `${params.row.brand}의 ${params.row.model} 자동차를 삭제하시겠습니까?`
              )
            )
              mutate(params.row._links.self.href);
          }}
        >
          삭제
        </button>
      ),
    },
  ];

  const { data, isSuccess, error } = useQuery({
    queryKey: ["cars"],
    queryFn: getCars,
  });

  if (!isSuccess) {
    return <span>Loading...🚀</span>;
  } else if (error) {
    return <span>자동차들을 불러오는 데 실패했습니다. ❗</span>;
  } else {
    return (
      <>
        <DataGrid
          rows={data}
          columns={columns}
          getRowId={(row) => row._links.self.href}
        />
        <Snackbar
          open={open}
          autoHideDuration={2000}
          onClose={() => setOpen(false)}
          message="선택한 항목이 삭제되었습니다.❗"
        />
      </>
    );
  }
}

export default Carlist;
```

# 생성 기능 추가
MUI 모달 폼을 이용하여 Car row를 추가할 수 있도록 할 에정이다. New Car라고 하는 버튼을 추가면 모달 폼이 열리게
한다. 그러면 모달 폼 내에는 여러 개의 input이 있어서 entity 상에서 final/@Nonnull 이 있는 field에 대한 모든 입력을 받고, 이를 저장하거나 취소할 수 있는 버튼을 내부에 구현할 예정

shpping list에서 add item 버튼과 , 그 내부 모달 폼 형식을 참조할 수 있을 것 같다.

```tsx
// AddCar.tsx
import { Dialog, DialogActions, DialogContent, DialogTitle } from "@mui/material";
import { Car } from "../types";
import { ChangeEvent, useState } from "react";


function AddCar() {
  const [open, setOpen] = useState(false)
  const [car, setCar] = useState({
    brand: "",
    model: "",
    color: "",
    registrationNumber: "",
    modelYear: 0,
    price: 0,
  });
  const handleClickOpen = () => setOpen(true);

  const handleClickClose = () => setOpen(false);

  const handleChange = (e: ChangeEvent<HTMLInputElement>) => setCar({ ...car, [e.target.name]: e.target.value });


  return (
    <>
      <button onClick={handleClickOpen}> New Car</button>
      <Dialog open={open}>
        <DialogTitle>New Car</DialogTitle>
        <DialogContent>
          <input type="text" name="brand" value={car.brand} placeholder="Brand" onChange={handleChange} /> <br />
          <input type="text" name="model" value={car.model} placeholder="Model" onChange={handleChange} /> <br />
          <input type="text" name="color" value={car.color} placeholder="Color" onChange={handleChange} /> <br />
          <input type="text" name="registrationNumber" value={car.registrationNumber} placeholder="Num" onChange={handleChange} /> <br />
          <input type="text" name="modelYear" value={car.modelYear} placeholder="M-Y" onChange={handleChange} /> <br />
          <input type="text" name="price" value={car.price} placeholder="Price" onChange={handleChange} /> <br />
        </DialogContent>
        <DialogActions>
          <button onClick={handleClickClose}> 저장 | Save </button>
          <button onClick={handleClickClose}> 취소 | Cancel </button>
        </DialogActions>
      </Dialog>
    </>
  );
}

export default AddCar;
```
나중에 전부 html 태그를 mui로 갈아 끼우고 현재까지 작성했을 때 브라우저 상에서의 화면은 어느 정도 구현되었다.
그럼 현재까지의 상황에서 이후의 작성 순서는 axios.post를 통해서 db로 지금 데이터 값을 넘겨서 저장할 수 있어야 할 것이고, 저장이 완료되었다면 갱신된 getCars()를 호출해야 한다. 또한 저장 / 취소가 된 이후에 input창이 초기화되는 것도 고려해볼만 하다. (그러면 수정 때는 초기화된 input이 아니라 기존 값들이 불러와져야된다.) 